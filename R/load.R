#' Read and preprocess an isomut file
#'
#' `read_isomut` reads an isomut file, adds a `read` column, optionally
#' filters according to given criteria and adds extra columns.
#'
#' @param file the name of the file which the data are to be read from.
#' @param minReads integer indicating the minimum number of reads
#' (default = 0L).
#' @param minCoverage double indicating the minimum coverage
#' (default = 0).
#' @param minMutFreq double indicating the minimum mutation frequency
#' (default = 0).
#' @param removePatterns character vector providing patterns in
#' sample_names that are to be removed.
#' @param extraColumns named list to generate extra columns. The list names are
#' the names of the new columns. The list elements can either be a vector of
#' length one (each row gets the same value for this column), a named vector
#' with names being a subset of the `sample_name` column in the original isomut
#' file, or a function that accepts those names as arguments.
#' @param removeFeatures whether certain genomic features should be removed.
#' @param featureData `GRanges` that contains features to be removed.
#' @param removeMito whether variants in mitochondrial DNA should be removed.
#'
#' @return a data.frame containing the filtered and preprocessed data.
#' @export
read_isomut <- function(file, minReads = 0L, minCoverage = 0, minMutFreq = 0,
                        removePatterns = NULL, extraColumns = NULL,
                        removeFeatures = TRUE, featureData = SGD_features,
                        removeMito = TRUE) {
  ## read data
  df <- read.table(file, header = TRUE)
  ## rename `sample_name` column
  df$file_name <- df$sample_name
  ## remove samples that match certain patterns
  if(!is.null(removePatterns)) {
    for(pattern in removePatterns) {
      df <- df[!grepl(pattern, df$file_name),]
    }
  }
  ## remove variants in mito
  if(removeMito) df <- df[df$chr != "Mito",]
  ## remove features
  if(removeFeatures) {
    df <- remove_features(df, featureData = featureData)
  }
  ## add `read` column
  df[["read"]] <- with(df, round(coverage * mut_freq))
  ## remove rows with too few reads
  if(minReads > 0) {
    df <- df[df$read > minReads,]
  }
  ## remove rows with low coverage
  if(minCoverage > 0) {
    df <- df[df$coverage > minCoverage,]
  }
  ## remove rows with low mutation frequency
  if(minMutFreq > 0) {
    df <- df[df$mut_freq > minMutFreq,]
  }
  ## replace cleanliness 42 with NA
  df$cleanliness[df$cleanliness==42] <- NA
  ## remove rownames
  rownames(df) <- NULL
  ## add extra columns
  if(!is.null(extraColumns)) {
    stopifnot(is.list(extraColumns), !is.null(names(extraColumns)))
    for(col_name in names(extraColumns)) {
      col_value <- extraColumns[[col_name]]
      stopifnot(is.vector(col_value) || is.function(col_value))
      if(is.function(col_value)) {
        df[[col_name]] <- vapply(df$file_name, col_value, character(1))
      } else {
        if(length(col_value) == 1) {
          df[[col_name]] <- col_value
        } else {
          stopifnot(df$file_name %in% names(col_value))
          df[[col_name]] <- col_value[df$file_name]
        }
      }
    }
  }
  ## order and remove possible duplicates
  df <- df[order(df$sample_name, df$chr, df$pos),]
  df <- df[!duplicated(df),]
  return(df)
}

#' Remove features
#'
#' Remove variants from isomut data if they match given genomic features
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`.
#' @param featureData a `GRanges` object that contains the features to be removed.
#'
#' @return a data.frame containing the filtered data.
#'
#' @importFrom GenomicRanges GRanges findOverlaps
#' @importFrom IRanges IRanges
#'
#' @export
remove_features <- function(isomut, featureData = SGD_features) {
  if(!is(featureData, "GRanges")) stop("`featureData` must be GRanges")
  mut_ranges <- GRanges(isomut$chr,
                        IRanges(isomut$pos, width = nchar(isomut$ref)))
  hits <- findOverlaps(mut_ranges, SGD_features)
  toKeep <- setdiff(seq_len(nrow(isomut)), hits@from)
  return(isomut[toKeep,])
}


#' Format indels
#'
#' Converts the sequence information about indels to a format that can be used
#' to predict the coding consequences.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`.
#' @param ref either the name of a fasta file containing the reference genome or
#' an object of class `FaFile`.
#'
#' @return A data.frame with formatted sequence information.
#'
#' @importFrom Rsamtools FaFile
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom Biostrings getSeq
#'
#' @export
format_indels <- function(isomut, ref = ref_scer) {
  if(with(isomut, all(ref != "-") && all(mut != "-"))) {
    return(isomut)
  }
  stopifnot(is(ref, "FaFile") || is.character(ref))
  if(is.character(ref)) ref <- FaFile(ref)
  mut_ranges <- GRanges(isomut$chr, IRanges(isomut$pos))
  mut_seq <- getSeq(ref, mut_ranges)
  ## format insertions
  ind_ins <- isomut$type == "INS"
  mut_seq_ins <- as.character(mut_seq[ind_ins])
  isomut$ref[ind_ins] <- mut_seq_ins
  isomut$mut[ind_ins] <- paste0(mut_seq_ins, isomut$mut[ind_ins])
  ## format deletions
  ind_del <- isomut$type == "DEL"
  mut_seq_del <- as.character(mut_seq[ind_del])
  isomut$ref[ind_del] <- paste0(mut_seq_del, isomut$ref[ind_del])
  isomut$mut[ind_del] <- mut_seq_del
  return(isomut)
}

#' Annotate isomut data
#'
#' `annotate_isomut` adds information about the location of variants (coding or
#' intergenic) and, for coding variants, about the affected gene(s) and the
#' position of the variant in the gene.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`
#' (minimally needs to contain `chr` and `pos` columns.
#' @param gtf_path path to annotation file in `gtf` or `gff` format.
#' @param noDups don't keep multiple annotations (e.g. when variant is inside
#' two genes on opposite strands). Default `FALSE`.
#'
#' @return a data.frame with additional columns regarding annotation.
#'
#' @importFrom GenomicFeatures makeTxDbFromGFF
#' @importFrom rtracklayer import
#' @importFrom VariantAnnotation locateVariants CodingVariants IntergenicVariants
#' @export
annotate_isomut <- function(isomut, gtf_path = txdb_scer, noDups = FALSE) {
  ## load annotation
  txdb <- suppressWarnings(makeTxDbFromGFF(gtf_path, metadata = "gene_id"))
  gtf <- import(gtf_path)
  gtf_genes <- gtf[gtf$type == "gene"]
  id2names <- setNames(gtf_genes$gene_name, gtf_genes$gene_id)
  ## convert isomut to GRanges
  mut_ranges <- GRanges(isomut$chr, IRanges(isomut$pos, width = 1))
  ## locate variants
  vars_coding <- suppressWarnings(locateVariants(mut_ranges, txdb,
                                                 CodingVariants()))
  vars_intergenic <- suppressWarnings(
    locateVariants(mut_ranges, txdb,
                   IntergenicVariants(upstream = 0 , downstream = 0))
    )
  vars <- rbind(as.data.frame(vars_coding), as.data.frame(vars_intergenic))
  ## get rid of additional annotations for the same variant
  if(noDups) {
    vars <- vars[!duplicated(vars$QUERYID), ]
  }
  vars <- vars[, c("seqnames", "start", "strand", "LOCATION", "LOCSTART", "GENEID")]
  names(vars) <- c("chr", "pos", "strand", "location", "nt_start", "gene_id")
  isomut_annotated <- merge(isomut, data.frame(vars), by = c("chr", "pos"), all.x = TRUE)
  isomut_annotated$gene_name <- id2names[isomut_annotated$gene_id]
  return(isomut_annotated)
}

#' Predict coding from variants
#'
#' predicts the consequences of variants in coding regions.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`.
#' @param ref either the name of a fasta file containing the reference genome or
#' an object of class `FaFile`.
#' @param gtf_path path to annotation file in `gtf` or `gff` format.
#' @param format_indels whether indels should be formatted (see `format_indels`
#' for details).
#' @param correct_coding whether coding be corrected if two variants hit the same
#' codon.
#'
#' @return a data.frame with additional columns regarding coding consequences.
#'
#' @importFrom Biostrings DNAStringSet translate reverseComplement
#' @importFrom VariantAnnotation predictCoding
#' @importFrom magrittr `%>%`
#' @importFrom dplyr mutate group_by filter n case_when
#'
#' @export
predict_coding <- function(isomut, ref = ref_scer, gtf_path = txdb_scer,
                           format_indels = TRUE, correct_coding = FALSE) {
  stopifnot(is(ref, "FaFile") || is.character(ref))
  if(is.character(ref)) ref <- FaFile(ref)
  txdb <- suppressWarnings(makeTxDbFromGFF(gtf_path, metadata = "gene_id"))
  ## format indels
  if(format_indels) isomut <- format_indels(isomut, ref)
  ## generate GRanges
  mut_ranges <- with(isomut, GRanges(chr, ranges = IRanges(start = pos,
                                                           width = nchar(ref))))
  varAllele <- DNAStringSet(isomut$mut)
  coding <- suppressWarnings(predictCoding(mut_ranges, txdb, ref, varAllele))
  coding <- as.data.frame(coding)
  coding$AA_start <- vapply(coding$PROTEINLOC, function(l) l[[1]], numeric(1))
  coding <- coding[, c("seqnames", "start", "GENEID", "CONSEQUENCE", "REFCODON",
                       "VARCODON", "REFAA", "VARAA", "AA_start")]
  names(coding) <- c("chr", "pos", "gene_id", "consequence", "ref_codon",
                     "var_codon", "ref_AA", "var_AA", "AA_start")
  if("gene_id" %in% names(isomut)) {
    isomut <- merge(isomut, coding, by = c("chr", "pos", "gene_id"),
                    all.x = TRUE, all.y = FALSE)
  } else {
    isomut <- merge(isomut, coding, by = c("chr", "pos"), all.x = TRUE,
                    all.y = TRUE)
  }
  isomut <- isomut[!duplicated(isomut),]
  if(correct_coding) isomut <- correct_coding(isomut)
  return(isomut)
}


#' Correct coding
correct_coding <- function(isomut) {
  if(!all(c("gene_id", "nt_start", "AA_start") %in% names(isomut))) {
    stop("Please annotate data first!")
  }
  ind_coding <- which(!is.na(isomut$gene_id))
  df_coding <- isomut[ind_coding,] %>%
    mutate(ind = ind_coding) %>%
    group_by(sample_name, gene_id, AA_start) %>%
    filter(n()==2) %>%
    mutate(codon_pos = ifelse(nt_start %% 3 %in% 1:2, nt_start %% 3, 3)) %>%
    mutate(var_codon = getVarCodon(codon_pos, mut, ref_codon, var_codon, strand, type),
        var_AA = case_when(
          !is.na(var_codon) & type=="SNV" ~ as.character(translate(DNAStringSet(var_codon), no.init.codon = TRUE)),
          TRUE ~ var_AA
        ),
        consequence = as.character(consequence),
        consequence = case_when(
          consequence %in% c("synonymous", "nonsynonymous", "nonsense") & var_AA == "*" ~ "nonsense",
          consequence %in% c("synonymous", "nonsynonymous", "nonsense") & var_AA == ref_AA ~ "synonymous",
          consequence %in% c("synonymous", "nonsynonymous", "nonsense") & var_AA != ref_AA ~ "nonsynonymous",
          TRUE ~ consequence
          )
        )
  isomut[df_coding$ind, c("var_codon", "var_AA", "consequence")] <- df_coding[, c("var_codon", "var_AA", "consequence")]
  return(isomut)
}

getVarCodon <- function(codon_pos, MUT, REFCODON, VARCODON, strand, type) {
  codon_pos <- codon_pos[!is.na(codon_pos)]
  MUT <- MUT[!is.na(codon_pos)]
  if(length(codon_pos)==0) return(NA)
  MUT <- ifelse(strand=="+", MUT, reverseComplement(DNAStringSet(MUT)))
  RC <- strsplit(REFCODON[[1]], "")[[1]]
  RC[codon_pos] <- MUT
  return(case_when(
    type=="SNV" & !is.na(codon_pos) ~ paste(RC, collapse = ""),
    TRUE ~ VARCODON
  ))
}


#' Find recurrently mutated genes
#'
#'
# find_recurrent <- function(isomut)
