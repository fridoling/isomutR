#' Read and preprocess an isomut file
#'
#' `read_isomut` reads an isomut file, adds a `read` column, optionally
#' filters according to given criteria and adds extra columns.
#'
#' @param file the name of the file which the data are to be read from.
#' @param minReads integer indicating the minimum number of reads
#' (default = 0L).
#' @param minCoverage double indicating the minimum coverage
#' (default = 0).
#' @param minMutFreq double indicating the minimum mutation frequency
#' (default = 0).
#' @param removePatterns character vector providing patterns in
#' sample_names that are to be removed.
#' @param extraColumns named list to generate extra columns. The list names are
#' the names of the new columns. The list elements can either be a vector of
#' length one (each row gets the same value for this column), a named vector
#' with names being a subset of the `sample_name` column in the original isomut
#' file, or a function that accepts those names as arguments.
#'
#' @return a data.frame containing the filtered and preprocessed data.
#' @export
read_isomut <- function(file, minReads = 0L, minCoverage = 0, minMutFreq = 0,
                        removePatterns = NULL, extraColumns = NULL) {
  ## read data
  df <- read.table(file, header = TRUE)
  ## rename `sample_name` column
  df$file_name <- df$sample_name
  df$sample_name <- NULL
  ## remove samples that match certain patterns
  if(!is.null(removePatterns)) {
    for(pattern in removePatterns) {
      df <- df[!grepl(pattern, df$file_name),]
    }
  }
  ## add `read` column
  df[["read"]] <- with(df, round(coverage * mut_freq))
  ## remove rows with too few reads
  if(minReads > 0) {
    df <- df[df$read > minReads,]
  }
  ## remove rows with low coverage
  if(minCoverage > 0) {
    df <- df[df$coverage > minCoverage,]
  }
  ## remove rows with mutation frequency
  if(minMutFreq > 0) {
    df <- df[df$mut_freq > minMutFreq,]
  }
  ## replace cleanliness 42 with NA
  df$cleanliness[df$cleanliness==42] <- NA
  rownames(df) <- NULL
  ## add extra columns
  if(!is.null(extra_columns)) {
    stopifnot(is.list(extra_columns), !is.null(names(extra_columns)))
    for(col_name in names(extra_columns)) {
      col_value <- extra_columns[[col_name]]
      stopifnot(is.vector(col_value) || is.function(col_value))
      if(is.function(col_value)) {
        df[[col_name]] <- vapply(df$file_name, col_value, character(1))
      } else {
        if(length(col_value) == 1) {
          df[[col_name]] <- col_value
        } else {
          stopifnot(df$file_name %in% names(col_value))
          df[[col_name]] <- col_value[df$file_name]
        }
      }
    }
  }
  ## order and remove possible duplicates
  df <- df[order(df$file_name, df$chr, df$pos),]
  df <- df[!duplicated(df),]
  return(df)
}

#' Format indels
#'
#' Converts the sequence information about indels to a format that can be used
#' to predict the coding consequences.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`.
#' @param ref either the name of a fasta file containing the reference genome or
#' an object of class `FaFile`.
#'
#' @return A data.frame with formatted sequence information.
format_indels <- function(isomut, ref) {
  if(with(isomut, all(ref != "-") && all(mut != "-"))) {
    return(isomut)
  }
  stopifnot(is(ref, "FaFile") || is.character(ref))
  if(is.character(ref)) ref <- FaFile(ref)
  mut_ranges <- GRanges(isomut$chr, IRanges(isomut$pos))
  mut_seq <- getSeq(ref, mut_ranges)
  ## format insertions
  ind_ins <- isomut$type == "INS"
  mut_seq_ins <- as.character(mut_seq[ind_ins])
  isomut$ref[ind_ins] <- mut_seq_ins
  isomut$mut[ind_ins] <- paste0(mut_seq_ins, isomut$mut[ind_ins])
  ## format deletions
  ind_del <- isomut$type == "DEL"
  mut_seq_del <- as.character(mut_seq[ind_del])
  isomut$ref[ind_del] <- paste0(mut_seq_del, isomut$ref[ind_del])
  isomut$mut[ind_del] <- mut_seq_del
  return(isomut)
}

#' Annotate isomut data
#'
#' `annotate_isomut` adds information about the location of variants (coding or
#' intergenic) and, for coding variants, about the affected gene(s) and the
#' position of the variant in the gene.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`
#' (minimally needs to contain `chr` and `pos` columns.
#' @param gtf_path path to annotation file in `gtf` or `gff` format.
#' @param noDups don't keep multiple annotations (e.g. when variant is inside
#' two genes on opposite strands). Default `FALSE`.
#'
#' @return a data.frame with additional columns regarding annotation.
#'
#' @export
annotate_isomut <- function(isomut, gtf_path, noDups = FALSE) {
  ## load annotation
  txdb <- suppressWarnings(makeTxDbFromGFF(gtf_path, metadata = "gene_id"))
  gtf <- import(gtf_path)
  gtf_genes <- gtf[gtf$type == "gene"]
  id2names <- setNames(gtf_genes$gene_name, gtf_genes$gene_id)
  ## convert isomut to GRanges
  mut_ranges <- GRanges(isomut$chr, IRanges(isomut$pos, width = 1))
  ## locate variants
  vars_coding <- suppressWarnings(locateVariants(mut_ranges, txdb, CodingVariants()))
  vars_intergenic <- suppressWarnings(locateVariants(mut_ranges, txdb, IntergenicVariants(upstream = 0 , downstream = 0)))
  vars <- rbind(as.data.frame(vars_coding), as.data.frame(vars_intergenic))
  ## get rid of additional annotations for the same variant
  if(noDups) {
    vars <- vars[!duplicated(vars$QUERYID), ]
  }
  vars <- vars[, c("seqnames", "start", "strand", "LOCATION", "LOCSTART", "GENEID")]
  names(vars) <- c("chr", "pos", "strand", "location", "nt_start", "gene_id")
  isomut_annotated <- merge(isomut, data.frame(vars), by = c("chr", "pos"), all.x = TRUE)
  isomut_annotated$gene_name <- id2names[isomut_annotated$gene_id]
  return(isomut_annotated)
}

#' Predict coding from variants
#'
#' predicts the consequences of variants in coding regions.
#'
#' @param isomut a data.frame of isomut data as generated by `read_isomut`.
#' @param ref either the name of a fasta file containing the reference genome or
#' an object of class `FaFile`.
#' @param gtf_path path to annotation file in `gtf` or `gff` format.
#' @param format_indels whether indels should be formatted (see `format_indels`
#' for details)
#'
#' @return a data.frame with additional columns regarding coding consequences.
#'
#' @export
predict_coding <- function(isomut, ref, gtf_path, format_indels = TRUE) {
  stopifnot(is(ref, "FaFile") || is.character(ref))
  if(is.character(ref)) ref <- FaFile(ref)
  txdb <- suppressWarnings(makeTxDbFromGFF(gtf_path, metadata = "gene_id"))
  ## format indels
  if(format_indels) isomut <- format_indels(isomut, ref)
  ## generate GRanges
  mut_ranges <- with(isomut, GRanges(chr, ranges = IRanges(start = pos, width = nchar(ref))))
  varAllele <- DNAStringSet(isomut$mut)
  coding <- suppressWarnings(predictCoding(mut_ranges, txdb, ref, varAllele))
  coding <- as.data.frame(coding)
  coding$AA_start <- vapply(coding$PROTEINLOC, function(l) l[[1]], numeric(1))
  coding <- coding[, c("seqnames", "start", "GENEID", "CONSEQUENCE", "REFCODON", "VARCODON", "REFAA", "VARAA", "AA_start")]
  names(coding) <- c("chr", "pos", "gene_id", "consequence", "ref_codon", "var_codon", "ref_AA", "var_AA", "AA_start")
  if("gene_id" %in% names(isomut)) {
    isomut <- merge(isomut, coding, by = c("chr", "pos", "gene_id"), all.x = TRUE, all.y = FALSE)
  } else {
    isomut <- merge(isomut, coding, by = c("chr", "pos"), all.x = TRUE, all.y = TRUE)
  }
  return(isomut)
}
